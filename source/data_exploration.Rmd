---
title: "Data exploration"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
bibliography: [references.json]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/research-institute-for-nature-and-forest.csl
---

```{r setup, include=FALSE}
# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
opts_knit$set(root.dir = here::here())

conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)

# Packages
library(tidyverse)
```

# Goal

Exploration of the data. Where are the bottlenecks? Missing data? ...

# Load data

```{r}
out_path <- file.path("data", "processed")

species_traits_final_nozero <- read_csv(
  file.path(out_path, "prop_data_per_trait_nozero.csv")
)
species_traits_final <- read_csv(file.path(out_path, "prop_data_per_trait.csv"))
```

# Missing data and duplicates

We do not know all the traits for the following species.

```{r}
species_traits_final %>%
  filter(is.na(trait_value)) %>%
  distinct(species_nl, trait_name) %>%
  mutate(val = 1) %>%
  pivot_wider(names_from = trait_name, values_from = val) %>%
  mutate(across(-c(species_nl), ~ replace(.x, .x == 1, cur_column()))) %>%
  unite("trait_name", -c(species_nl), sep = ", ", na.rm = TRUE) %>%
  kable()
```

Some species have more than one trait value within the same trait.

```{r}
dubbles <- species_traits_final %>%
  count(species_nl, period, trait_name) %>%
  filter(n > 1) %>%
  distinct(species_nl, trait_name) %>%
  inner_join(
    distinct(
      species_traits_final, species_nl, trait_name,
      trait_value
    ),
    by = join_by(species_nl, trait_name)
  )

dubbles %>%
  kable()
```

## Resolve issues

We avoid problems for species with more than one trait value within the same trait by giving a suffix number to the species in a separate column. By grouping the data, it is possible to circumvent any issues (see code further on). We also filter out `NA`'s.

```{r}
design_df <- dubbles %>%
  rowid_to_column("id") %>%
  mutate(species_new = ifelse(id %% 2 != 0,
    paste(species_nl, 1, sep = "_"),
    paste(species_nl, 2, sep = "_")
  )) %>%
  select(-id)

species_traits_final_new <- species_traits_final %>%
  full_join(design_df, by = join_by(species_nl, trait_name, trait_value)) %>%
  mutate(
    species_new = ifelse(!is.na(species_new), species_new,
      ifelse(species_nl %in% unique(design_df$species_nl),
        paste(species_nl, 1, sep = "_"), species_nl
      )
    )
  ) %>%
  filter(!is.na(trait_value))
```


# Summaries
## Univariate

How many data do we have for each trait?

```{r}
univar_summary <- species_traits_final_new %>%
  count(trait_name, trait_value, period) %>%
  distinct(trait_name, trait_value, n) %>%
  mutate("n <= 10" = ifelse(n <= 10, "YES", "no")) %>%
  arrange(trait_name, trait_value)

univar_summary %>%
  kable()
```

We see some trait values with less than 10 species.

```{r}
table(univar_summary$`n <= 10`)
```

## Bivariate

We can look at combinations of traits. Do we see any interesting correlations?

```{r}
cross_tab <- function(df, row, column, print = TRUE) {
  require("dplyr")
  require("tidyr")
  require("data.table")
  cross_table <- df %>%
    filter(.data$trait_name %in% c(row, column)) %>%
    distinct(
      .data$species_nl, .data$species_new, .data$trait_name,
      .data$trait_value
    ) %>%
    pivot_wider(
      id_cols = c("species_nl", "species_new"), names_from = .data$trait_name,
      values_from = .data$trait_value
    ) %>%
    # Fill in missing trait values for species that occur twice
    group_by(.data$species_nl) %>%
    arrange(.data$species_nl, .data$species_new, !!sym(row), !!sym(column)) %>%
    mutate(
      "{row}" := ifelse(is.na(!!sym(row)), # nolint: object_name_linter.
        first(!!sym(row)), !!sym(row)
      ),
      "{column}" := ifelse(is.na(!!sym(column)), # nolint: object_name_linter.
        first(!!sym(column)), !!sym(column)
      )
    ) %>%
    ungroup() %>%
    # Pivot wider can recreate NA's for missing trait values
    # (which were filtered out before in the dataset)
    drop_na() %>%
    # How many species per trait combination?
    count(!!sym(row), !!sym(column)) %>%
    pivot_wider(
      id_cols = !!sym(row), names_from = !!sym(column),
      values_from = .data$n
    ) %>%
    mutate_all(~ replace(., is.na(.), 0))

  if (isTRUE(print)) {
    return(print(cross_table))
  } else {
    return(cross_table)
  }
}
```

```{r}
small_traits <- univar_summary %>%
  filter(n <= 10) %>%
  pull(trait_value)

filtered_df <- species_traits_final_new %>%
  filter(!trait_value %in% small_traits)

combinations <- combn(unique(filtered_df$trait_name), 2)

for (i in seq_len(ncol(combinations))) {
  combo <- combinations[, i]

  if (!(setequal(c("HabitatTemperature", "TempHum"), combo) ||
    setequal(c("TempHum", "HabitatHumidity"), combo))) {
    print("------------------------------------------------")
    print(combo)
    cross_tab(filtered_df, combo[1], combo[2])
  }
}
```

# Geometric means
## Separate traits

We calculate the geometric mean and 95 % confidence interval based on 1000 bootstrap samples for all traits with more than 10 species.

```{r}
geometric_mean <- filtered_df %>%
  select(-c(sum_per_period, n_grids)) %>%
  pivot_wider(names_from = period, values_from = rel_prop) %>%
  filter(p1980_2012 != 0 & p2013_2022 != 0) %>%
  mutate(
    sci = p2013_2022 / p1980_2012,
    log_sci = log(sci)
  ) %>%
  group_by(trait_name, trait_value) %>%
  summarise(
    mean_cl_boot(log_sci,
      conf.int = .95
    ),
    n = n()
  ) %>%
  mutate(
    msci = exp(y) - 1,
    msci_lwr = exp(ymin) - 1,
    msci_upr = exp(ymax) - 1
  )

geometric_mean %>%
  select(-c(y, ymin, ymax)) %>%
  arrange(trait_name, trait_value) %>%
  kable()
```

```{r}
traits <- sort(unique(geometric_mean$trait_name))

for (t in traits) {
  p <- geometric_mean %>%
    filter(trait_name == t) %>%
    mutate(col_var = case_when(
      msci_lwr > 0 ~ "chartreuse3",
      msci_upr < 0 ~ "coral",
      msci_lwr < 0 & msci_lwr > -0.2 & msci_upr > 0 & msci_upr < 0.25 ~ "gold",
      TRUE ~ "skyblue",
    )) %>%
    ggplot(aes(y = msci, x = trait_value)) +
    geom_hline(yintercept = 0, linetype = 2) +
    geom_hline(yintercept = c(-0.2, 0.25), linetype = 3) +
    geom_point(aes(colour = col_var),
      size = 2,
      position = position_dodge(width = 0.6)
    ) +
    geom_errorbar(aes(ymin = msci_lwr, ymax = msci_upr, colour = col_var),
      width = 0.25, position = position_dodge(width = 0.6)
    ) +
    geom_text(aes(y = msci_upr, label = n, group = trait_value),
      vjust = -1,
      colour = "firebrick", position = position_dodge(width = 0.6)
    ) +
    scale_y_continuous(expand = expansion(mult = 0.2)) +
    scale_colour_identity() +
    labs(x = "", y = "Multispecies Change Index", title = t) +
    theme(legend.position = "")
  print(p)
}
```

## Combinations of traits

```{r}
for (i in seq_len(ncol(combinations))) {
  combo <- combinations[, i]

  if (!(setequal(c("HabitatTemperature", "TempHum"), combo) ||
    setequal(c("TempHum", "HabitatHumidity"), combo))) {
    row <- combo[1]
    column <- combo[2]
    combo_frame <- filtered_df %>%
      filter(trait_name %in% combo) %>%
      pivot_wider(
        id_cols = c(
          species_nl, species_new, n_grids, period, sum_per_period,
          rel_prop
        ),
        names_from = trait_name, values_from = trait_value
      ) %>%
      # Fill in missing trait values for species that occur twice
      group_by(species_nl) %>%
      arrange(species_nl, species_new, !!sym(row), !!sym(column)) %>%
      mutate(
        "{row}" := ifelse(is.na(!!sym(row)), # nolint: object_name_linter.
          first(!!sym(row)), !!sym(row)
        ),
        "{column}" := ifelse(is.na(!!sym(column)), # nolint: object_name_linter.
          first(!!sym(column)), !!sym(column)
        )
      ) %>%
      ungroup() %>%
      # Pivot wider can recreate NA's for missing trait values
      # (which were filtered out before in the dataset)
      drop_na() %>%
      # How many species per trait combination?
      group_by_at(c("period", combo)) %>%
      mutate(n = n()) %>%
      ungroup() %>%
      filter(
        n > 10
      ) %>%
      select(-c(sum_per_period, n_grids)) %>%
      pivot_wider(names_from = period, values_from = rel_prop) %>%
      filter(p1980_2012 != 0 & p2013_2022 != 0)

    combo_geometric_mean <- combo_frame %>%
      mutate(
        sci = p2013_2022 / p1980_2012,
        log_sci = log(sci)
      ) %>%
      group_by_at(c(combo, "n")) %>%
      summarise(
        mean_cl_boot(log_sci,
          conf.int = .95
        ),
        .groups = "drop"
      ) %>%
      mutate(
        msci = exp(y) - 1,
        msci_lwr = exp(ymin) - 1,
        msci_upr = exp(ymax) - 1
      )

    p <- combo_geometric_mean %>%
      mutate(
        col_var = case_when(
          msci_lwr > 0 ~ "chartreuse3",
          msci_upr < 0 ~ "coral",
          msci_lwr < 0 & msci_lwr > -0.2 & msci_upr > 0 & msci_upr < 0.25
          ~ "gold",
          TRUE ~ "skyblue",
        ),
        trait_value = paste(.[[combo[1]]], .[[combo[2]]], sep = "\n")
      ) %>%
      ggplot(aes(y = msci, x = .data[[combo[1]]])) +
      geom_hline(yintercept = 0, linetype = 2) +
      geom_hline(yintercept = c(-0.2, 0.25), linetype = 3) +
      geom_point(aes(colour = col_var),
        size = 2,
        position = position_dodge(width = 0.6)
      ) +
      geom_errorbar(aes(ymin = msci_lwr, ymax = msci_upr, colour = col_var),
        width = 0.25, position = position_dodge(width = 0.6)
      ) +
      geom_text(aes(y = msci_upr, label = n, group = trait_value),
        vjust = -1, colour = "firebrick",
        position = position_dodge(width = 0.6)
      ) +
      scale_y_continuous(expand = expansion(mult = 0.2)) +
      scale_colour_identity() +
      labs(
        x = "", y = "Multispecies Change Index",
        title = paste(combo, collapse = " - ")
      ) +
      theme(
        legend.position = "",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
      ) +
      facet_wrap(~ .data[[combo[2]]])
    print(p)
  }
}
```

