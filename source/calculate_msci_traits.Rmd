---
title: "Calculate MSCI for specific traits and combinations"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
opts_knit$set(root.dir = here::here())

conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)
conflicted::conflicts_prefer(stats::lag)
conflicted::conflicts_prefer(brms::ar)
conflicted::conflicts_prefer(brms::dstudent_t)
conflicted::conflicts_prefer(brms::pstudent_t)
conflicted::conflicts_prefer(brms::qstudent_t)
conflicted::conflicts_prefer(brms::rstudent_t)

# Packages
library(tidyverse)
library(brms)
library(tidybayes)

# Source
source(here("source", "summarise_brms_models.R"))
source(here("source", "set_priors_brms.R"))
```

# Goal

Fit models and calculate MSCI for specific trait combinations.

# Load data

```{r}
data_path <- file.path("data", "processed")

species_traits_final <- read_csv(file.path(data_path,
                                           "prop_data_per_trait.csv"))
```

# Automatisation

-   make a list with each trait (combination)
-   `lapply()` to create list of filtered dataframes
-   `relevel()` traits and/or filter dataframes
-   visualise group sizes
-   `lapply()` to create formula list
-   fit models in for loop
-   check MCMC convergence in for loop
-   check model fit in for loop
-   ...

# Data preparation
## Trait combinations

We consider a number of trait combinations.

```{r}
trait_combinations <- list(
  c("Biotope", "Phagy"),
  c("Biotope", "EllenbergN"),
  c("colourVariation", "Size"),
  c("Activity", "nGenerations"),
  c("OverwinteringStage", "nGenerations"),
  c("Phagy", "LarvalFoodSource2"),
  c("Phagy", "EllenbergN"),
  c("Phagy", "nGenerations"),
  c("Phagy", "Size"),
  c("Phagy", "TempHum"),
  c("LarvalFoodSource2", "EllenbergN"),
  c("EllenbergN", "TempHum"),
  c("nGenerations", "Distribution"),
  c("nGenerations", "Size"),
  c("nGenerations", "TempHum"),
  c("Distribution", "TempHum"),
  c("Size", "TempHum")
)
trait_combinations
```


## Filter dataframes per trait combination

We create a list of dataframes per trait combination.

```{r}
trait_df_list_raw <- lapply(trait_combinations, function(combo) {
  if (length(combo) == 2) {
    row <- combo[1]
    column <- combo[2]
    out <- species_traits_final %>%
      filter(trait_name %in% combo) %>%
      pivot_wider(
        id_cols = c("species_nl", "species_new", "n_grids", "period",
                    "sum_per_period"),
        names_from = "trait_name",
        values_from = "trait_value"
      ) %>%
      # Fill in missing trait values for species that occur twice
      group_by(species_nl) %>%
      arrange(species_nl, species_new, !!sym(row), !!sym(column)) %>%
      mutate(
        "{row}" := ifelse(is.na(!!sym(row)), # nolint: object_name_linter.
          first(!!sym(row)), !!sym(row)
        ),
        "{column}" := ifelse(is.na(!!sym(column)), # nolint: object_name_linter.
          first(!!sym(column)), !!sym(column)
        )
      ) %>%
      ungroup() %>%
      # How many species per trait combination?
      group_by_at(c("period", combo)) %>%
      mutate(n_species = n()) %>%
      ungroup() %>%
      select(-species_nl) %>%
      mutate(species_nl = species_new) %>%
      select(-species_new) %>%
      select_at(c("species_nl", "n_grids", "period", "sum_per_period", combo,
                  "n_species"))
  } else if (length(combo) == 1) {
    species_traits_final %>%
      filter(trait_name == combo) %>%
      pivot_wider(
        id_cols = c("species_nl", "species_new", "n_grids", "period",
                    "sum_per_period"),
        names_from = "trait_name",
        values_from = "trait_value"
      ) %>%
      # How many species per trait combination?
      group_by_at(c("period", combo)) %>%
      mutate(n_species = n()) %>%
      ungroup() %>%
      select(-species_nl) %>%
      mutate(species_nl = species_new) %>%
      select(-species_new) %>%
      select_at(c("species_nl", "n_grids", "period", "sum_per_period", combo,
                  "n_species"))
  } else {
    stop("Function not implemented for combinations of more than 2 traits.",
         call. = FALSE)
  }
  return(out)
})

names_trait_df_list <- sapply(trait_combinations, function(combo) {
  paste(combo, collapse = "_")
})

names(trait_df_list_raw) <- names_trait_df_list
```

We set reference levels such that the models can converge (reference group does not contain missing data).
We also filter out `LarvalFoodSource2:Other` which contains only two species and `Distribution:Cosmopolitan` which contains only five species.

```{r}
trait_df_list <- lapply(trait_df_list_raw, function(df) {
  if ("Biotope" %in% names(df)) {
    df <- df %>%
      mutate(Biotope = relevel(factor(Biotope), "Woodland"))
  }
  if ("LarvalFoodSource2" %in% names(df)) {
    df <- df %>%
      filter(LarvalFoodSource2 != "Other") %>%
      mutate(LarvalFoodSource2 = relevel(factor(LarvalFoodSource2),
                                         "Shrubs_Trees"))
  }
  if ("Phagy" %in% names(df)) {
    df <- df %>%
      mutate(Phagy = relevel(factor(Phagy), "Polyphagous"))
  }
  if ("Distribution" %in% names(df)) {
    df <- df %>%
      filter(Distribution != "Cosmopolitan") %>%
      mutate(Distribution = relevel(factor(Distribution), "Palaearctic"))
  }
  if ("TempHum" %in% names(df)) {
    df <- df %>%
      mutate(TempHum = relevel(factor(TempHum), "Hot_Dry"))
  }
  if ("EllenbergN" %in% names(df)) {
    df <- df %>%
      mutate(EllenbergN = relevel(factor(EllenbergN), "NutrientPoor"))
  }
  if ("colourVariation" %in% names(df)) {
    df <- df %>%
      mutate(colourVariation = relevel(factor(colourVariation), "Invariable"))
  }
  if ("Size" %in% names(df)) {
    df <- df %>%
      mutate(Size = relevel(factor(Size), "Intermediate"))
  }
  if ("Activity" %in% names(df)) {
    df <- df %>%
      mutate(Activity = relevel(factor(Activity), "NightActive"))
  }
  if ("nGenerations" %in% names(df)) {
    df <- df %>%
      mutate(nGenerations = relevel(factor(nGenerations), "1"))
  }
  if ("OverwinteringStage" %in% names(df)) {
    df <- df %>%
      mutate(OverwinteringStage = relevel(factor(OverwinteringStage), "Pupa"))
  }

  return(df)
})
```

How many species do we have per trait combination?

```{r}
for (i in seq_along(trait_combinations)) {
  combo <- trait_combinations[[i]]

  if (length(combo) == 2) {
    p <- trait_df_list[[i]] %>%
      ggplot(aes(x = .data[[combo[1]]], y = .data[[combo[2]]])) +
        geom_tile(aes(fill = n_species), colour = "white") +
        geom_text(aes(label = n_species)) +
        scale_fill_gradient(low = "red", high = "green") +
        labs(fill = "number of\nspecies", x = "", y = "",
             title = gsub("_", " ~ ", names(trait_df_list)[i]))

    print(p)
  }
}
```


# Model fitting
## Model fit preparation

We set the MCMC parameters and make a list of model formulae as specified in `model_specification_msci.Rmd`.

```{r}
# MCMC parameters
nchains <- 3 # number of chains
niter <- 10000 # number of iterations (incl. burn-in)
burnin <- niter / 4 # number of initial samples to discard (burn-in)
nparallel <- nchains # number of cores used for parallel computing
thinning <- 3
```

```{r}
formula_list <- lapply(trait_combinations, function(combo) {
  bf(paste("n_grids", "~", paste(c("period", combo), collapse = " * "),
           " + offset(log(sum_per_period)) + (1 + period || species_nl)"))
})
names(formula_list) <- names(trait_df_list)
```

## Fit models

```{r}
# create cache directory if not yet available
dir.create(here("source", "source/brms_cache"), FALSE)
```

We fit the models in a for loop and store them in a list.

```{r}
model_msci_list <- vector("list", length = length(trait_df_list))
model_msci_list_names <- vector(length = length(trait_df_list))

for (i in seq_along(trait_df_list)) {
  combo_name <- names(trait_df_list)[i]
  obj_name <- paste0("fit_msci_", combo_name)

  # set priors: https://github.com/paul-buerkner/brms/issues/783
  prior_combo <- set_priors_brms(combo_name,
                                 trait_df_list[[combo_name]],
                                 formula_list[[combo_name]])

  print(paste("Busy fitting", obj_name, "..."))
  assign(obj_name,
         brm(formula = formula_list[[combo_name]],
             data = trait_df_list[[combo_name]],
             family = poisson(),
             prior = prior_combo,
             chains = nchains,
             warmup = burnin,
             iter = niter,
             cores = nparallel,
             thin = thinning,
             file = paste0("source/brms_cache/", obj_name),
             file_refit = "on_change"))

  model_msci_list[[i]] <- get(obj_name)
  model_msci_list_names[i] <- combo_name
}

names(model_msci_list) <- model_msci_list_names
```


## Checking model convergence

We check MCMC convergence based on posterior densities, trace plots and the Gelman-Rubin diagnostic for each parameter in each model.

```{r}
for (model in model_msci_list) {
  model <- model_msci_list[[i]]
  print(paste("Convergence model", names(model_msci_list)[i]))
  print(plot(model, ask = FALSE))
}
```

```{r}
rhat_list <- get_rhats(model_msci_list)
show_rhat(do.call(rbind.data.frame, rhat_list))
```

Convergence is good.


## Checking model fit

We check model fit based on posterior predictive checks where we compare the observed outcome to simulated datasets from the posterior predictive distribution.

```{r}
for (i in seq_along(model_msci_list)) {
  title <- paste("Fit referentiemodel", names(model_msci_list)[i])
  model <- model_msci_list[[i]]
  print(
    pp_check(
      model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = "period"
      ) +
      ggtitle(title)
    )

  print(
    pp_check(model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = str_split_i(names(model_msci_list)[i], "_", 1)
      ) +
      ggtitle(title)
    )

  print(
    pp_check(model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = str_split_i(names(model_msci_list)[i], "_", 2)
      ) +
      ggtitle(title)
    )
}
```

Model fit is good.
