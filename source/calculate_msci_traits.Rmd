---
title: "Calculate MSCI for specific traits and combinations"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
opts_knit$set(root.dir = here::here())

conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)
conflicted::conflicts_prefer(stats::lag)
conflicted::conflicts_prefer(brms::ar)
conflicted::conflicts_prefer(brms::dstudent_t)
conflicted::conflicts_prefer(brms::pstudent_t)
conflicted::conflicts_prefer(brms::qstudent_t)
conflicted::conflicts_prefer(brms::rstudent_t)

# Packages
library(tidyverse)
library(brms)
library(tidybayes)

# Source
source(here("source", "summarise_brms_models.R"))
```

# Goal

Fit models and calculate MSCI for specific trait combinations.

# Load data

```{r}
data_path <- file.path("data", "processed")

species_traits_final <- read_csv(file.path(data_path,
                                           "prop_data_per_trait.csv"))
```

# Automatisation

-   make a list with each trait (combination)
-   `lapply()` to create list of filtered dataframes
-   visualise and filter on group sizes
-   `lapply()` to create formula list
-   fit models in for loop
-   check MCMC convergence in for loop
-   check model fit in for loop
-   ...

# Data preparation
## Trait combinations

We consider a number of trait combinations.

```{r}
trait_combinations <- list(
  c("Biotope", "Phagy"),
  c("Biotope", "EllenbergN"),
  c("colourVariation", "Size"),
  c("Activity", "nGenerations"),
  c("OverwinteringStage", "nGenerations"),
  c("Phagy", "LarvalFoodSource2"),
  c("Phagy", "EllenbergN"),
  c("Phagy", "nGenerations"),
  c("Phagy", "Size"),
  c("Phagy", "TempHum"),
  c("LarvalFoodSource2", "EllenbergN"),
  c("EllenbergN", "TempHum"),
  c("nGenerations", "Distribution"),
  c("nGenerations", "Size"),
  c("nGenerations", "TempHum"),
  c("Distribution", "TempHum"),
  c("Size", "TempHum")
)
trait_combinations
```


## Filter dataframes per trait combination

We create a list of dataframes per trait combination.

```{r}
trait_df_list <- lapply(trait_combinations, function(combo) {
  if (length(combo) == 2) {
    row <- combo[1]
    column <- combo[2]
    out <- species_traits_final %>%
      filter(trait_name %in% combo) %>%
      pivot_wider(
        id_cols = c("species_nl", "species_new", "n_grids", "period",
                    "sum_per_period"),
        names_from = "trait_name",
        values_from = "trait_value"
      ) %>%
      # Fill in missing trait values for species that occur twice
      group_by(species_nl) %>%
      arrange(species_nl, species_new, !!sym(row), !!sym(column)) %>%
      mutate(
        "{row}" := ifelse(is.na(!!sym(row)), # nolint: object_name_linter.
          first(!!sym(row)), !!sym(row)
        ),
        "{column}" := ifelse(is.na(!!sym(column)), # nolint: object_name_linter.
          first(!!sym(column)), !!sym(column)
        )
      ) %>%
      ungroup() %>%
      # How many species per trait combination?
      group_by_at(c("period", combo)) %>%
      mutate(n_species = n()) %>%
      ungroup() %>%
      select(-species_nl) %>%
      mutate(species_nl = species_new) %>%
      select(-species_new) %>%
      select_at(c("species_nl", "n_grids", "period", "sum_per_period", combo,
                  "n_species"))
  } else if (length(combo) == 1) {
    species_traits_final %>%
      filter(trait_name == combo) %>%
      pivot_wider(
        id_cols = c("species_nl", "species_new", "n_grids", "period",
                    "sum_per_period"),
        names_from = "trait_name",
        values_from = "trait_value"
      ) %>%
      # How many species per trait combination?
      group_by_at(c("period", combo)) %>%
      mutate(n_species = n()) %>%
      ungroup() %>%
      select(-species_nl) %>%
      mutate(species_nl = species_new) %>%
      select(-species_new) %>%
      select_at(c("species_nl", "n_grids", "period", "sum_per_period", combo,
                  "n_species"))
  } else {
    stop("Function not implemented for combinations of more than 2 traits.",
         call. = FALSE)
  }
  return(out)
})

names_trait_df_list <- sapply(trait_combinations, function(combo) {
  paste(combo, collapse = "_")
})

names(trait_df_list) <- names_trait_df_list
```

How many species do we have per trait combination?

```{r}
for (i in seq_along(trait_combinations)) {
  combo <- trait_combinations[[i]]

  if (length(combo) == 2) {
    p <- trait_df_list[[i]] %>%
      ggplot(aes(x = .data[[combo[1]]], y = .data[[combo[2]]])) +
        geom_tile(aes(fill = n_species), colour = "white") +
        geom_text(aes(label = n_species)) +
        scale_fill_gradient(low = "red", high = "green") +
        labs(fill = "number of\nspecies", x = "", y = "",
             title = gsub("_", " ~ ", names(trait_df_list)[i]))

    print(p)
  }
}
```

```{r}
filter_size <- 10
```

We only keep trait groups with more than `r filter_size` species.

```{r}
trait_df_list_filtered <- lapply(trait_df_list, function(df) {
  df %>%
    filter(n_species > filter_size)
})
names(trait_df_list_filtered) <- names(trait_df_list)
```

These are the groups that remain:

```{r}
for (i in seq_along(trait_combinations)) {
  combo <- trait_combinations[[i]]

  if (length(combo) == 2) {
    p <- trait_df_list_filtered[[i]] %>%
      ggplot(aes(x = .data[[combo[1]]], y = .data[[combo[2]]])) +
        geom_tile(fill = "cornflowerblue", colour = "white") +
        geom_text(aes(label = n_species)) +
        #scale_fill_gradient(low = "red", high = "green") +
        labs(fill = "number of\nspecies", x = "", y = "",
             title = gsub("_", " ~ ", names(trait_df_list)[i]))

    print(p)
  }
}
```


# Model fitting
## Model fit preparation

We set the MCMC parameters and make a list of model formulae as specified in `model_specification_msci.Rmd`.

```{r}
# MCMC parameters
nchains <- 3 # number of chains
niter <- 10000 # number of iterations (incl. burn-in)
burnin <- niter / 4 # number of initial samples to discard (burn-in)
nparallel <- nchains # number of cores used for parallel computing
thinning <- 2
```

```{r}
formula_list <- lapply(trait_combinations, function(combo) {
  bf(paste("n_grids", "~", paste(c("period", combo), collapse = " * "),
           " + offset(log(sum_per_period)) + (1 + period || species_nl)"))
})
```

## Fit models

```{r}
# create cache directory if not yet available
dir.create(here("source", "source/brms_cache"), FALSE)
```

We fit the models in a for loop and store them in a list.

```{r}
model_msci_list <- vector("list", length = length(trait_df_list_filtered))
model_msci_list_names <- vector(length = length(trait_df_list_filtered))

for (i in seq_along(trait_df_list_filtered)) {
  combo_name <- names(trait_df_list_filtered)[i]
  obj_name <- paste0("fit_msci_", combo_name)
  print(paste("Busy fitting", obj_name, "..."))
  assign(obj_name,
         brm(formula = formula_list[[i]],
             data = trait_df_list_filtered[[i]],
             family = poisson(),
             chains = nchains,
             warmup = burnin,
             iter = niter,
             cores = nparallel,
             thin = thinning,
             file = paste0("source/brms_cache/", obj_name),
             file_refit = "on_change"))

  model_msci_list[[i]] <- get(obj_name)
  model_msci_list_names[i] <- combo_name
}

names(model_msci_list) <- model_msci_list_names
```


## Checking model convergence

We check MCMC convergence based on posterior densities, trace plots and the Gelman-Rubin diagnostic for each parameter.

```{r}
for (model in model_msci_list) {
  model <- model_msci_list[[i]]
  print("Convergence model", names(model_msci_list)[i])
  print(plot(model, ask = FALSE))
}
```

```{r}
get_rhats <- function(models) {
  require("dplyr")
  require("tibble")
  # get rhats and make dataframe
  rhat_list <- lapply(seq_along(models), function(i) {
    model <- models[[i]]
    rhats <- brms::rhat(model)
    as.data.frame(rhats) %>%
      rownames_to_column("variable") %>%
      rename_with(~paste0("rhat"), .cols = starts_with("rhat")) %>%
      mutate(model = names(models)[i])
    })
  names(rhat_list) <- names(models)
  return(rhat_list)
}

show_rhat <- function(rhat_df) {
  require("ggplot2")
  palette <- colorRampPalette(RColorBrewer::brewer.pal(9,
               name = "Set1"))(length(unique(rhat_df$variable)))
  rhat_df |>
    ggplot(aes(y = .data$rhat, x = .data$model, colour = .data$variable)) +
      geom_hline(yintercept = c(1, 1.1), colour = "grey", linetype = "dashed") +
      geom_jitter(width = 0.2, height = 0, size = 1) +
      scale_colour_manual(values = palette) +
      theme(legend.position = "",
            axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
      labs(x = "", y = "Gelman-Rubin diagnostic")
}
```

```{r}
rhat_list <- get_rhats(model_msci_list)
show_rhat(do.call(rbind.data.frame, rhat_list))
```

Models did not converge because of missing groups.
Can we fit the models without filtering the data?
We can exclude groups afterwards.

```{r}
trait_combinations_to_fit <- sapply(seq_along(rhat_list), function(i) {
  df <- rhat_list[[i]]
  if (max(df$rhat) > 1.1) {
    return(names(rhat_list)[i])
  } else {
    return(NA)
  }
})
index <- !is.na(trait_combinations_to_fit)
trait_combinations_to_fit <- trait_combinations_to_fit[index]
```

```{r}
model2_msci_list <- vector("list", length = length(trait_df_list))
model2_msci_list_names <- vector(length = length(trait_df_list))

for (i in seq_along(trait_df_list)) {
  combo_name <- names(trait_df_list)[i]
  if (combo_name %in% trait_combinations_to_fit){
    obj_name <- paste0("fit2_msci_", combo_name)
    print(paste("Busy fitting", obj_name, "..."))
    assign(obj_name,
           brm(formula = formula_list[[i]],
               data = trait_df_list[[i]],
               family = poisson(),
               chains = nchains,
               warmup = burnin,
               iter = niter,
               cores = nparallel,
               thin = thinning,
               file = paste0("source/brms_cache/", obj_name),
               file_refit = "on_change"))
  } else {
    obj_name <- get(paste0("fit_msci_", combo_name))
    print(paste("Loading", obj_name, "..."))
  }

  model2_msci_list[[i]] <- get(obj_name)
  model2_msci_list_names[i] <- combo_name
}

names(model2_msci_list) <- model2_msci_list_names
```


## Checking model fit

We check model fit based on posterior predictive checks were we compare the observed outcome to simulated datasets from the posterior predictive distribution.

```{r}
for (i in seq_along(model_msci_list)) {
  title <- paste("Fit referentiemodel", names(model_msci_list)[i])
  model <- model_msci_list[[i]]
  print(
    pp_check(
      model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = "period"
      ) +
      ggtitle(title)
    )

  print(
    pp_check(model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = trait_combinations[[i]][1]
      ) +
      ggtitle(title)
    )

  print(
    pp_check(model,
      type = "dens_overlay_grouped", ndraws = 100,
      group = trait_combinations[[i]][2]
      ) +
      ggtitle(title)
    )
}
```
